#include "pch.h"
#include "Dx11BackEnd.h"
#if __has_include("Dx11BackEnd.g.cpp")
#include "Dx11BackEnd.g.cpp"
#endif

#include "Content\Sample3DSceneRenderer.h"
#include "Content\SampleFpsTextRenderer.h"
#include "SpinningCubeMain.h"

#define USE_INDEPENDENT_INPUT_SOURCE 1

// WARNING: This file is automatically generated by a tool. Do not directly
// add this file to your project, as any changes you make will be lost.
// This file is a stub you can use as a starting point for your implementation.
//
// To add a copy of this file to your project:
//   1. Copy this file from its original location to the location where you store 
//      your other source files (e.g. the project root). 
//   2. Add the copied file to your project. In Visual Studio, you can use 
//      Project -> Add Existing Item.
//   3. Delete this comment and the 'static_assert' (below) from the copied file.
//      Do not modify the original file.
//
// To update an existing file in your project:
//   1. Copy the relevant changes from this file and merge them into the copy 
//      you made previously.
//    
// This assertion helps prevent accidental modification of generated files.
//static_assert(false, "This file is generated by a tool and will be overwritten. Open this error and view the comment for assistance.");

using namespace winrt;  // for other namespaces
using namespace Microsoft::UI::Input;           // for InputPointerSourceDeviceKinds
using namespace Microsoft::UI::Xaml::Controls;  // for SwapChainPanel
using namespace Microsoft::UI::Xaml::Controls::Primitives;
using namespace Microsoft::UI::Xaml::Data;
using namespace Microsoft::UI::Xaml::Input;
using namespace Microsoft::UI::Xaml::Media;
using namespace Microsoft::UI::Xaml::Navigation;
using namespace Windows::Foundation;            // for IAsyncAction
using namespace Windows::System::Threading;     // for WorkItemHandler
using namespace Windows::Graphics::Display;     // for DisplayInformation
using namespace Windows::System::Threading;
using namespace Windows::UI::Core;
using namespace concurrency;
using namespace DirectX;		// for Colors

namespace winrt::ProtoWRC::implementation
{
	Dx11BackEnd::Dx11BackEnd() :
		m_windowVisible(true),
		m_coreInput(nullptr),
		m_deviceResources(nullptr),
		m_p(nullptr)
	{
		
	}
	Dx11BackEnd::~Dx11BackEnd()
	{
		if (m_main != nullptr)
		{
			m_main->StopRenderLoop();
		}
	}
	// dummy
	void Dx11BackEnd::Initialize(int32_t _width, int32_t _height)
	{
		m_width = _width;
		m_height = _height;
	}
	// Get hosting surface
	void Dx11BackEnd::SetSwapChainToBackEnd(winrt::Microsoft::UI::Xaml::Controls::SwapChainPanel const& _panel)
	{
		m_deviceResources = std::make_shared<DX::DeviceResources>();
		// TODO: Provide parameters for swapchain format, depth/stencil format, and backbuffer count.
		//   Add DX::DeviceResources::c_AllowTearing to opt-in to variable rate displays.
		//   Add DX::DeviceResources::c_EnableHDR for HDR10 display.

		m_scp = std::make_shared<winrt::Microsoft::UI::Xaml::Controls::SwapChainPanel>(_panel);

		m_scp->CompositionScaleChanged(TypedEventHandler<Microsoft::UI::Xaml::Controls::SwapChainPanel, IInspectable>(this, &Dx11BackEnd::OnCompositionScaleChanged));
		m_scp->SizeChanged(winrt::Microsoft::UI::Xaml::SizeChangedEventHandler(this, &Dx11BackEnd::OnSwapChainPanelSizeChanged));
		m_deviceResources->SetSwapChainPanel(*m_scp);

#if USE_INDEPENDENT_INPUT_SOURCE
		// Register our SwapChainPanel to get independent input pointer events
		auto workItemHandler = WorkItemHandler([this](IAsyncAction)
		{
			// The CoreIndependentInputSource will raise pointer events for the specified device types on whichever thread it's created on.
			InputPointerSourceDeviceKinds deviceKind = (InputPointerSourceDeviceKinds)
				((uint32_t)Microsoft::UI::Input::InputPointerSourceDeviceKinds::Mouse |
				 (uint32_t)Microsoft::UI::Input::InputPointerSourceDeviceKinds::Touch |
				 (uint32_t)Microsoft::UI::Input::InputPointerSourceDeviceKinds::Pen);
			m_coreInput = m_scp->CreateCoreIndependentInputSource(
				deviceKind
			);

			// Register for pointer events, which will be raised on the background thread.
			m_coreInput.PointerPressed({ this, &Dx11BackEnd::SwapChainPanel_OnPointerPressed });
			m_coreInput.PointerMoved({ this, &Dx11BackEnd::SwapChainPanel_OnPointerMoved });
			m_coreInput.PointerReleased({ this, &Dx11BackEnd::SwapChainPanel_OnPointerReleased });
		});

		// Run task on a dedicated high priority background thread.
		m_inputLoopWorker = ThreadPool::RunAsync(workItemHandler, WorkItemPriority::High, WorkItemOptions::TimeSliced);
#else
		swapChainPanel().PointerPressed({ this, &DirectXPage::swapChainPanel_PointerPressed });
		swapChainPanel().PointerMoved({ this, &DirectXPage::swapChainPanel_PointerMoved });
		swapChainPanel().PointerReleased({ this, &DirectXPage::swapChainPanel_PointerReleased });
#endif
		m_main = std::unique_ptr<WRCClient::SpinningCubeMain>(new WRCClient::SpinningCubeMain(m_deviceResources));
	}

	void Dx11BackEnd::StartRendering()
	{
		if (m_main == nullptr) return;
		m_main->StartRenderLoop();
	}
	void Dx11BackEnd::StopRendering()
	{
		if (m_main == nullptr) return;
		m_main->StopRenderLoop();
	}

	void Dx11BackEnd::SetPointer(winrt::Microsoft::UI::Input::PointerPoint const& _p)
	{
		m_p = _p;
	}

	// Window event handlers.

	winrt::event_token Dx11BackEnd::CollectionChanged(winrt::Microsoft::UI::Xaml::Interop::NotifyCollectionChangedEventHandler const& handler)
	{
		return event_token();
	}
	void Dx11BackEnd::CollectionChanged(winrt::event_token const& token) noexcept
	{
		 ;
	}
	void Dx11BackEnd::OnVisibilityChanged(winrt::Windows::UI::Core::CoreWindow const& sender, winrt::Windows::UI::Core::VisibilityChangedEventArgs const& args)
	{
		m_windowVisible = args.Visible();
		if (m_windowVisible)
		{
			m_main->StartRenderLoop();
		}
		else
		{
			m_main->StopRenderLoop();
		}
	}
	void Dx11BackEnd::OnDpiChanged(winrt::Windows::Graphics::Display::DisplayInformation const& sender, winrt::Windows::Foundation::IInspectable const& args)
	{
		critical_section::scoped_lock lock(m_main->GetCriticalSection());
		// Note: The value for LogicalDpi retrieved here may not match the effective DPI of the app
		// if it is being scaled for high resolution devices. Once the DPI is set on DeviceResources,
		// you should always retrieve it using the GetDpi method.
		// See DeviceResources.cpp for more details.
		m_deviceResources->SetDpi(sender.LogicalDpi());
		m_main->CreateWindowSizeDependentResources();
	}
	void Dx11BackEnd::OnOrientationChanged(winrt::Windows::Graphics::Display::DisplayInformation const& sender, winrt::Windows::Foundation::IInspectable const& args)
	{
		critical_section::scoped_lock lock(m_main->GetCriticalSection());
		m_deviceResources->SetCurrentOrientation(sender.CurrentOrientation());
		m_main->CreateWindowSizeDependentResources();
	}
	void Dx11BackEnd::OnDisplayContentsInvalidated(winrt::Windows::Graphics::Display::DisplayInformation const& sender, winrt::Windows::Foundation::IInspectable const& args)
	{
		critical_section::scoped_lock lock(m_main->GetCriticalSection());
		m_deviceResources->ValidateDevice();
	}
	void Dx11BackEnd::OnCompositionScaleChanged(winrt::Microsoft::UI::Xaml::Controls::SwapChainPanel const& sender, winrt::Windows::Foundation::IInspectable const& args)
	{
		critical_section::scoped_lock lock(m_main->GetCriticalSection());
		m_deviceResources->SetCompositionScale(sender.CompositionScaleX(), sender.CompositionScaleY());
		m_main->CreateWindowSizeDependentResources();
	}
	void Dx11BackEnd::OnSwapChainPanelSizeChanged(winrt::Windows::Foundation::IInspectable const& sender, winrt::Microsoft::UI::Xaml::SizeChangedEventArgs const& e)
	{
		critical_section::scoped_lock lock(m_main->GetCriticalSection());
		m_deviceResources->SetLogicalSize(e.NewSize());
		m_main->CreateWindowSizeDependentResources();
	}

	void Dx11BackEnd::swapChainPanel_PointerPressed(winrt::Windows::Foundation::IInspectable const& sender, winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs const& e)
	{
		m_main->StartTracking();
	}
	void Dx11BackEnd::swapChainPanel_PointerMoved(winrt::Windows::Foundation::IInspectable const& sender, winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs const& e)
	{
		// Update the pointer tracking code.
		if (m_main->IsTracking())
		{
			m_main->TrackingUpdate(e.GetCurrentPoint(*m_scp).Position().X);
		}
	}
	void Dx11BackEnd::swapChainPanel_PointerReleased(winrt::Windows::Foundation::IInspectable const& sender, winrt::Microsoft::UI::Xaml::Input::PointerRoutedEventArgs const& e)
	{
		m_main->StopTracking();
	}

	void Dx11BackEnd::SwapChainPanel_OnPointerPressed(winrt::Microsoft::UI::Input::InputPointerSource const& sender, winrt::Microsoft::UI::Input::PointerEventArgs const& e)
	{
		// When the pointer is pressed begin tracking the pointer movement.
		m_main->StartTracking();
	}
	void Dx11BackEnd::SwapChainPanel_OnPointerMoved(winrt::Microsoft::UI::Input::InputPointerSource const& sender, winrt::Microsoft::UI::Input::PointerEventArgs const& e)
	{
		// Update the pointer tracking code.
		if (m_main->IsTracking())
		{
			m_main->TrackingUpdate(e.CurrentPoint().Position().X);
		}
	}
	void Dx11BackEnd::SwapChainPanel_OnPointerReleased(winrt::Microsoft::UI::Input::InputPointerSource const& sender, winrt::Microsoft::UI::Input::PointerEventArgs const& e)
	{
		// Stop tracking pointer movement when the pointer is released.
		m_main->StopTracking();
	}
}
